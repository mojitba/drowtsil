<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>drowtsil API documentation</title>
<meta name="description" content="This script allows the user to create wordlist for targeted subject. Use only for security audit, penetration testing and education purposes â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>drowtsil</code></h1>
</header>
<section id="section-intro">
<p>This script allows the user to create wordlist for targeted subject. Use only for security audit, penetration testing and education purposes.</p>
<p>This tool accepts two list in form of text file (.txt) or from command line and returns a wordlist in (.txt) format.</p>
<h2 id="program">Program</h2>
<p>Drowtsil(reverse of word list)-v1.0 - Another wordlist generator for penetration testing and education purposes</p>
<h2 id="usage">Usage</h2>
<p>python drowtsil.py -h</p>
<h2 id="author">Author</h2>
<p>Mojtaba Hemmati
github.com/moji1tba 3/21/2024</p>
<p>License:
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307
USA</p>
<p>See 'LICENSE' for more information.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This script allows the user to create wordlist for targeted subject. Use only for security audit, penetration testing and education purposes.

This tool accepts two list in form of text file (.txt) or from command line and returns a wordlist in (.txt) format.

Program:
    Drowtsil(reverse of word list)-v1.0 - Another wordlist generator for penetration testing and education purposes

Usage:
    python drowtsil.py -h

Author:
    Mojtaba Hemmati
    github.com/moji1tba 3/21/2024

License:
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

See &#39;LICENSE&#39; for more information.

&#34;&#34;&#34;
from timeit import default_timer
import argparse
from pathlib import Path
from itertools import permutations
import re
from errno import ENOSPC
from multiprocessing import (
    cpu_count,
    Pool,
    get_all_start_methods,
    set_start_method,
    Semaphore,
)

from src.modules import helpers

logo = &#34;&#34;&#34;
    ____                     __       _ __
   / __ \_________ _      __/ /______(_) /
  / / / / ___/ __ \ | /| / / __/ ___/ / / 
 / /_/ / /  / /_/ / |/ |/ / /_(__  ) / /  
/_____/_/   \____/|__/|__/\__/____/_/_/   
                                                                                                                                             
 Wordlist Generator for Security Audit
                 V.1
&#34;&#34;&#34;


def _create_parser(process_number_default):
    &#34;&#34;&#34;Create and return a parser (argparse.ArgumentParser instance) for main() function.

    :param process_number_default: default value for the number of processes (compute with multiprocessing.cpu_count())
    :type input_list: int
    :returns: an instance from argparse.ArgumentParser class contains switches with their values.
    :rtype: &lt;class &#39;argparse.ArgumentParser&#39;&gt;
    &#34;&#34;&#34;

    parser = argparse.ArgumentParser(
        description=&#34;Another Wordlist Generator for Security Audit Purposes&#34;,
        prog=&#34;Drowtsil WordList Generator&#34;,
        epilog=&#34;Thanks for using %(prog)s!&#34;,
    )
    #user&#39;s provided paths or words
    parser.add_argument(
        &#34;-i&#34;, &#34;--input&#34;, type=str, nargs=&#34;+&#34;, help=&#34;List of constant input words&#34;
    )
    parser.add_argument(
        &#34;-ti&#34;,
        &#34;--tmpinp&#34;,
        type=str,
        nargs=&#34;+&#34;,
        default=None,
        help=&#34;List of temporary input words, every time each one is\n\t selected and added to constant words list&#34;,
    )
    parser.add_argument(
        &#34;-f&#34;, &#34;--filename&#34;, type=str, help=&#34;Path to constant Wordlist file&#34;
    )
    parser.add_argument(
        &#34;-ft&#34;,
        &#34;--tmpfile&#34;,
        type=str,
        default=None,
        help=&#34;Path to temporary Wordlist file, every time each one selected\n\t and added to constant words list&#34;,
    )
    parser.add_argument(
        &#34;-o&#34;,
        &#34;--output&#34;,
        type=str,
        default=&#34;./output.txt&#34;,
        help=&#34;Path of generated wordlist (default is \&#34;./output.txt\&#34;)&#34;,
    )
    #user&#39;s prefer options
    parser.add_argument(
        &#34;-l&#34;,
        &#34;--level&#34;,
        type=int,
        default=1,
        choices=[0, 1, 2, 3],
        help=&#34;Level of operation (0,1,2,3) (default is 1)&#34;,
    )
    parser.add_argument(
        &#34;-p&#34;,
        &#34;--pattern&#34;,
        type=str,
        nargs=&#34;+&#34;,
        default=None,
        help=&#39;Pattern of words, Enter like &#34;pattern&#34; &#34;index&#34;. Example: 0 for first and 1000 for the end of word or other indexes&#39;,
    )
    parser.add_argument(
        &#34;-r&#34;, &#34;--regex&#34;, type=str, default=None, help=&#34;Regex to match words&#34;
    )
    parser.add_argument(
        &#34;-pn&#34;,
        &#34;--pernumber&#34;,
        type=int,
        default=2,
        help=&#34;Minimum number of words to generate permutations like start with 2-word permutation (default is 2)&#34;,
    )
    parser.add_argument(
        &#34;-ps&#34;,
        &#34;--process&#34;,
        type=int,
        nargs=&#34;?&#34;,
        const=process_number_default,
        default=None,
        help=&#34;Number of processes in the pool (default is number of logical cores - 1)&#34;,
    )
    parser.add_argument(
        &#34;-max&#34;, type=int, default=63, help=&#34;Maximum length of the preshared key (default is 63)&#34;
    )
    parser.add_argument(
        &#34;-min&#34;, type=int, default=8, help=&#34;Minimum length of the preshared key (default is 8)&#34;
    )
    #operations options
    parser.add_argument(
        &#34;-u&#34;, &#34;--upper&#34;, action=&#34;store_true&#34;, help=&#34;Enable upper case function&#34;
    )
    parser.add_argument(
        &#34;-lo&#34;, &#34;--lower&#34;, action=&#34;store_true&#34;, help=&#34;Enable lower case function&#34;
    )
    parser.add_argument(
        &#34;-c&#34;, &#34;--capital&#34;, action=&#34;store_true&#34;, help=&#34;Enable capitalize function&#34;
    )
    parser.add_argument(
        &#34;-lt&#34;,
        &#34;--leet_case&#34;,
        action=&#34;store_true&#34;,
        help=&#34;Enable leet case function, replace &#39;a&#39; with &#39;@&#39;, &#39;s&#39; with &#39;$&#39; and etc&#34;,
    )
    parser.add_argument(
        &#34;-t&#34;,
        &#34;--toggle&#34;,
        type=int,
        default=None,
        const=0,
        nargs=&#34;?&#34;,
        help=&#34;Enable toggle case function with index (default is 0)&#34;,
    )
    parser.add_argument(
        &#34;-s&#34;, &#34;--swap&#34;, action=&#34;store_true&#34;, help=&#34;Enable swap case function&#34;
    )
    parser.add_argument(
        &#34;-st&#34;, &#34;--sentence&#34;, action=&#34;store_true&#34;, help=&#34;Enable sentence case function&#34;
    )
    parser.add_argument(
        &#34;-rv&#34;, &#34;--reverse&#34;, action=&#34;store_true&#34;, help=&#34;Reverse every word in level 0&#34;
    )
    parser.add_argument(
        &#34;-a&#34;,
        &#34;--alternating&#34;,
        action=&#34;store_true&#34;,
        help=&#34;transform text into the form that alternates between lowercase and uppercase&#34;,
    )
    parser.add_argument(
        &#34;-all&#34;, action=&#34;store_true&#34;, help=&#34;Apply all text transform functions in levels 0 and 3&#34;
    )
    parser.add_argument(
        &#34;-n&#34;,&#34;--numbers&#34;, type=int, default=0, help=&#34;Add consecutive numbers at the end of strings in level 1&#34;
    )
    parser.add_argument(
        &#34;-ch&#34;,&#34;--chars&#34;, action=&#34;store_true&#34;, help=&#34;Add consecutive characters at the end of strings in level 1&#34;
    )
    return parser


def create_wordlist(iter, min, max, level, capital, regexp, pattern_dict, word_counter):
    &#34;&#34;&#34;Get an iterable object and create a wordlist with selected options 
    
    Create a wordlist by joining items from iterators in one string. every iterator contains a list of all permutations
    tuples. if a specific pattern is provided, it will be added and then passed to the private function (_add_to_wordlist). if
    the level selected by the user is 2 and the capital switch doesn&#39;t disable, capitalized words also are added to the wordlist.

    :param iter: iterable returns from itertools.permutations
    :type iter: itertools.permutations
    :param min: minimum size of word by char
    :type min: int
    :param max: maximum size of word by char
    :type max: int
    :param level: user&#39;s selected level
    :type level: int
    :param capital: enable capitalize case transformation
    :type capital: bool
    :param regexp: regex pattern to match
    :type regexp: str
    :param pattern_dict: pattern provided by the user
    :type pattern_dict: dict
    :param word_counter: tracking generated word number
    :type word_counter: int
    :returns: returns a list of generated words and their number
    :rtype: tuple
    &#34;&#34;&#34;
    wordlist = []
    for item in iter:
        word = &#34;&#34;.join(item)
        if pattern_dict:
            word = _add_pattern(word, pattern_dict)

        word_counter = _add_to_wordlist(wordlist, word, min, max, regexp, word_counter)
        #apply capitalize operation in level 2
        if level == 2 and capital:
            cap_word = &#34;&#34;.join(helpers.capitalize(item))
            if pattern_dict:
                cap_word = _add_pattern(cap_word, pattern_dict)

            word_counter = _add_to_wordlist(
                wordlist, cap_word, min, max, regexp, word_counter
            )

    return wordlist, word_counter

def _add_pattern(word, pattern_dict):
    &#34;&#34;&#34;Add the pattern provided by the user to the specified index of the word

    :param word: a word from the wordlist
    :type word: str
    :param pattern_dict: a dictionary of pattern  in shape {index:&#34;pattern&#34;} (index 0 for first of word, 1000 for end of word)
    :type pattern_dict: dict
    :returns: a word with an appended pattern
    :rtype: str
    &#34;&#34;&#34;
    for i in pattern_dict.keys():
        if i == 0:
            word = pattern_dict.get(i) + word
        elif i == 1000:
            word = word + pattern_dict.get(i)
        else:
            word = word[:i] + pattern_dict.get(i) + word[i:]
    return word


def _add_to_wordlist(wordlist, word, min, max, regexp, word_counter):
    &#34;&#34;&#34;A private function that adds a word to the wordlist.

    :param wordlist: an empty list for adding words 
    :type wordlist: list
    :param word: generated word that is going to be added to the wordlist
    :type word: str
    :param min: minimum size of word by char
    :type min: int
    :param max: maximum size of word by char
    :type max: int
    :param regexp: regex pattern to match
    :type regexp: str
    :param word_counter: tracking generated word number
    :type word_counter: int
    :returns: returns number of generated words
    :rtype: int
    &#34;&#34;&#34;
    if len(word) &gt;= min and len(word) &lt;= max:
        if regexp != None:
            if re.match(regexp, word):
                wordlist.append(word)
                word_counter += 1

        else:
            wordlist.append(word)
            word_counter += 1

    return word_counter


def level_zero(args, current_words):
    &#34;&#34;&#34;It performs when the user&#39;s selected level is 0. Get a list of words and arguments provided by the user and apply selected functions on
      all items.

    list of functions: 
      -upper case
      -lower case,
      -toggle case
      -swap case
      -capitalize case
      -leet case
      -reverse case
      -alternating case 

    :param args: arguments provide by the user
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :param current_words: a merged list of constant words and temporary words
    :type current_words: list
    :returns: a tuple contains a list of transformed words and a list of operations that have been done 
    :rtype: tuple
    &#34;&#34;&#34;
    words = []
    output_print = []
    if args.all or args.upper:
        words += helpers.upper_case(current_words)
        output_print.append(&#34;upper case&#34;)
    if args.all or args.lower:
        words += helpers.lower_case(current_words)
        output_print.append(&#34;lower case&#34;)
    if args.all or args.toggle is not None:
        if args.all and args.toggle is None:
            args.toggle = 0
        words += helpers.toggle_case(current_words, args.toggle)
        output_print.append(&#34;toggle case&#34;)
    if args.all or args.swap:
        words += helpers.swap_case(current_words)
        output_print.append(&#34;swap case&#34;)
    if args.all or args.capital:
        words += helpers.capitalize(current_words)
        output_print.append(&#34;capitalize&#34;)
    if args.all or args.leet_case:
        words += helpers.leet_case(current_words)
        output_print.append(&#34;leet_case&#34;)
    if args.all or args.reverse:
        words += helpers.reverse(current_words)
        output_print.append(&#34;reverse&#34;)
    if args.all or args.alternating:
        words += helpers.alternating_case(current_words)
        output_print.append(&#34;alternating&#34;)
    return set(words), output_print

def level_one(constant_words, temporary_words, numbers, chars):
    &#34;&#34;&#34;It performs when the user&#39;s selected level is 1. Get a list of URLs or other texts and add consecutive numbers or letters or
    items of temporary_words at the end.
    
    :param constant_words: a list of constant words
    :type constant_words: list
    :param temporary_words: a list of temporary words
    :type temporary_words: list
    :param numbers: limit for consecutive numbers - also enable this feature
    :type numbers: int
    :param chars: enable adding consecutive characters
    :type chars: bool
    :returns: a tuple contains a list of transformed words and the length of the wordlist 
    :rtype: tuple
    &#34;&#34;&#34;
    wordlist = []
    urls = _is_url(constant_words)
    # if input list contains urls
    if urls:
        for url in urls:
            if numbers:
                for i in range(numbers):
                    try:
                        new_url = &#34;&#34;.join(url[0]+str(i)+url[1])
                    except IndexError:
                        new_url = &#34;&#34;.join(url[0]+str(i))
                    wordlist.append(new_url)
            if temporary_words != &#34;&#34;:
                for tmp_item in temporary_words:
                    try:
                        new_url = &#34;&#34;.join(url[0]+str(tmp_item)+url[1])
                    except IndexError:
                        new_url = &#34;&#34;.join(url[0]+str(tmp_item))
                    wordlist.append(new_url)
            if chars:
                for char_item in helpers.characters:
                    try:
                        new_url = &#34;&#34;.join(url[0]+str(char_item)+url[1])
                    except IndexError:
                        new_url = &#34;&#34;.join(url[0]+str(char_item))
                    wordlist.append(new_url)
    # if input list does not contain urls.
    else:
        if numbers:
            for i in range(numbers):
                for item in constant_words:
                    wordlist.append(item + str(i))
        if temporary_words != &#34;&#34;:
            for tmp_item in temporary_words:
                for item in constant_words:
                    wordlist.append(item + tmp_item)
        if chars:
            for char_item in helpers.characters:
                for item in constant_words:
                    wordlist.append(item + char_item)
                    
    return wordlist, len(wordlist)


def _is_url(input_list):
    &#34;&#34;&#34;It&#39;s a private function for checking if the list contains URLs or not.
    
    :param input_list: list of strings
    :type input_list: list
    :returns: a list of lists containing URLs and their suffixes.
    :rtype: list
    &#34;&#34;&#34;
    urls = [re.findall(&#39;(?:(?:https?|ftp):\/\/)?[\w/\-?=%.]+\.[\w/\-&amp;?=%.]+&#39;, item) for item in input_list]
    split_urls =[re.split(r&#34;([.]{1}[a-zA-Z]+$)&#34;, item[0]) for item in urls ]
    return split_urls

def level_three(
    wordlist,
    args,
    output_dir,
    word_counter,
    semaphore,
    write_function,
):
    &#34;&#34;&#34;It performs when the user&#39;s selected level is 2. Get a list of words and arguments provided by the user and apply selected functions on
      every item of the wordlist.

      list of functions: 
      -upper case
      -sentence case
      -toggle case
      -capitalize case
      -leet case
      -alternating case 

    :param wordlist: a list contains all permutations of input words
    :type wordlist: list
    :param args: arguments provided by the user
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :param output_dir: path to the output directory
    :type output_dir: str
    :param word_counter: tracking generated word number
    :type word_counter: int
    :param semaphore: semaphore for prevent of mutual exclusion (default is 1)
    :type semaphore: multiprocessing.synchronize.Semaphore
    :param write_function: an instance of helpers.write_to_file function
    :type write_function: function
    :returns: returns number of generated words
    :rtype: int
    &#34;&#34;&#34;
    write_function(wordlist, semaphore, output_dir)
    temp_wordlist = []
    if args.all or args.leet_case:
        temp_wordlist += helpers.leet_case(wordlist)
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        #clear temp wordlist to save memory
        temp_wordlist.clear()
    if args.all or args.upper:
        temp_wordlist += set(helpers.upper_case(wordlist))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear()
    if args.all or args.sentence:
        temp_wordlist += set(helpers.sentence_case(wordlist))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear() 
    if args.all or args.toggle is not None:
        if args.all and args.toggle is None:
            args.toggle = 0
        temp_wordlist += set(helpers.toggle_case(wordlist, index=args.toggle))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear()
    if args.all or args.alternating:
        temp_wordlist += set(helpers.alternating_case(wordlist))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear()
    #clear wordlist to save memory
    wordlist.clear()

    return word_counter


# private function for testing purposes
def _extract_user_input(args, parser, read_function):
    &#34;&#34;&#34;A private function that reads input words from files and returns an appropriate message if files are not found.

    :param args: arguments provided by the user
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :param parser: an instance of argparse.ArgumentParser
    :type parser: &lt;class &#39;argparse.ArgumentParser&#39;&gt;
    :param read_function: an instance of helpers.read_from_file function
    :type read_function: function
    :returns: a tuple containing a list of constant words and a list of temporary words
    :rtype: tuple
    &#34;&#34;&#34;
    try:
        if args.filename and args.tmpfile:
            target_cons_dir = Path(args.filename)
            target_tmp_dir = Path(args.tmpfile)
            cons_words = read_function(target_cons_dir)
            tmp_words = read_function(target_tmp_dir)

        elif args.filename and args.tmpinp:
            target_cons_dir = Path(args.filename)
            cons_words = read_function(target_cons_dir)
            tmp_words = args.tmpinp

        elif args.input and args.tmpfile:
            target_tmp_dir = Path(args.tmpfile)
            cons_words = args.input
            tmp_words = read_function(target_tmp_dir)

        elif args.input and args.tmpinp:
            cons_words = args.input
            tmp_words = args.tmpinp
        
        elif args.input and (args.level == 0 or args.level == 1):
            cons_words = args.input
            tmp_words = &#34;&#34;

        elif args.filename and (args.level == 0 or args.level == 1):
            target_cons_dir = Path(args.filename)
            cons_words = read_function(target_cons_dir)
            tmp_words = &#34;&#34;

        else:
            parser.exit(
                1,
                message=&#34;[!] ERROR: Input constant words or temporary words doesn&#39;t provide.\n&#34;,
            )
    except FileNotFoundError:
        parser.exit(
            1,
            message=&#34;[!] ERROR: Incorrectly specified path of input files. Try again!\n&#34;,
        )
    except PermissionError:
        parser.exit(
            1,
            message=&#34;[!] ERROR: Permission denied to the specified path of input files. Try again!\n&#34;,
        )
    return cons_words, tmp_words


# private function for unittesting purposes
def _extract_pattern(args):
    &#34;&#34;&#34;A private function that creates a dictionary of patterns provided by the user.

    :param args: arguments provided by the user - example: [&#39;pattern1&#39;, &#39;index1&#39;]
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :returns: a dictionary of patterns {index: &#34;pattern&#34;,}
    :rtype: dict
    &#34;&#34;&#34;
    if args.pattern:
        pattern_dict = dict()
        for p in range(int(len(args.pattern) / 2)):
            pindex = int(args.pattern.pop())
            pstr = args.pattern.pop()
            pattern_dict[pindex] = pstr
    else:
        pattern_dict = None
    return pattern_dict


# private function for unittesting purposes
def _calculate_total(tmp_words, len_input, pernumber):
    &#34;&#34;&#34;A private function that calculates the total number of iterations to use in helpers.printProgressBar function.

    :param tmp_words: a list of temporary words which each will be added to constant words to create a current word list
    :type tmp_words: list
    :param len_input: length of constant word list
    :type len_input: int
    :param pernumber: minimum length permutations of elements in the iterable
    :type pernumber: int
    :returns: an integer that will be passed to helpers.printProgressBar function
    :rtype: int
    &#34;&#34;&#34;
    if tmp_words:
        total = ((len_input + 2) - pernumber) * len(tmp_words)
    else:
        total = len_input
    return total

# private function for unittesting purposes
def _checking_permutation_number(len_input, parser):
    &#34;&#34;&#34;A private function that calculates the number of permutations for input words, to notify the user of the high volume of computation

    :param len_input: length of constant word list
    :type len_input: int
    :param parser: an instance of argparse.ArgumentParser
    :type parser: &lt;class &#39;argparse.ArgumentParser&#39;&gt;
    :returns: None
    :rtype: None
    &#34;&#34;&#34;
    import math
    possible_permutation = math.factorial(len_input)
    answer = input(f&#34;Your input file contains {len_input} words with {possible_permutation} permutations. this number of permutation may require heavy computation and memory and disk resources.\n recommended try again with fewer words. Are you sure to continue? (-y for YES -n for NO - default is NO) &#34;)
    if answer == &#34;-n&#34; or answer == &#34;&#34;:
        parser.exit(
        1,
        message=&#34;[!] Try again with fewer words!\n&#34;,
    )

def main(args=None):
    &#34;&#34;&#34;Main function to generate a wordlist

    :param args: arguments provided by the user - optional
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :returns: None
    :rtype: None
    &#34;&#34;&#34;
    #specifies start method for multiprocessing mode
    start_method = get_all_start_methods()
    set_start_method(start_method[0])
    #calculate logical cpu cores
    process_number_default = cpu_count()
    #record progress time
    start_time = default_timer()
    #assign functions for testing purpose
    write_function = helpers.write_to_file
    read_function = helpers.read_from_file
    #create argument parser
    parser = _create_parser(process_number_default)
    args = parser.parse_args()
    #extract constant and temporary lists
    cons_words, tmp_words = _extract_user_input(args, parser, read_function)
    len_input = len(cons_words)
    total = _calculate_total(tmp_words, len_input, args.pernumber)
    output_dir = Path(args.output)
    semaphore = Semaphore(1)
    iteration_number = 0
    word_counter = 0
    print_bar = helpers.printProgressBar
    pattern_dict = _extract_pattern(args)
    print(logo)

    # emptying previous output file
    mode = &#34;w&#34;
    with open(output_dir, mode):
        pass
    
    try:
        if args.level == 0:
                wordlist, output_print = level_zero(args, cons_words)
                write_function(wordlist, semaphore, output_dir)
                word_counter = len(wordlist)

        elif args.level == 1:
                wordlist, word_counter = level_one(cons_words, tmp_words, args.numbers, args.chars)
                write_function(wordlist, semaphore, output_dir)
        
        else:
            print_bar(iteration_number, total, length=50)

            for item in tmp_words:
                #each time initialize a list of words from the constant list and one item from the temporary list
                current_words = [item]
                current_words += cons_words
                # checking for high number of permutations
                if len_input+1 &gt;= 12:
                    _checking_permutation_number(len_input, parser)
                #calculate permutation without multiprocessing
                if not args.process:
                    for i in range(args.pernumber, len_input + 2):
                        iter = permutations(current_words, i)
                        wordlist, word_counter = create_wordlist(
                            iter,
                            args.min,
                            args.max,
                            args.level,
                            args.capital,
                            args.regex,
                            pattern_dict,
                            word_counter,
                        )

                        if args.level == 2:
                            write_function(wordlist, semaphore, output_dir)

                            iteration_number += 1
                            helpers.printProgressBar(iteration_number, total, length=50)
                            
                        if args.level == 3:
                            word_counter = level_three(
                                wordlist,
                                args,
                                output_dir,
                                word_counter,
                                semaphore,
                                write_function,
                            )
                            iteration_number += 1
                            helpers.printProgressBar(iteration_number, total, length=50)
                if args.process:
                    starmap_iterable = [
                        (current_words, i) for i in range(args.pernumber, len_input + 2)
                    ]
                    #calculate permutation with multiprocessing
                    with Pool(processes=args.process) as pool:
                        for iter in pool.starmap(permutations, starmap_iterable):
                            wordlist, word_counter = create_wordlist(
                                iter,
                                args.min,
                                args.max,
                                args.level,
                                args.capital,
                                args.regex,
                                pattern_dict,
                                word_counter,
                            )
                            if args.level == 1:
                                write_function(wordlist, semaphore, output_dir)

                                iteration_number += 1
                                helpers.printProgressBar(
                                    iteration_number, total, length=50
                                )
                            if args.level == 2:
                                word_counter = level_three(
                                    wordlist,
                                    args,
                                    output_dir,
                                    word_counter,
                                    semaphore,
                                    write_function,
                                )
                            iteration_number += 1
                            helpers.printProgressBar(iteration_number, total, length=50)

    except MemoryError:
        print(
            &#34;[!] ERROR:(Memory error) There isn&#39;t enough memory to calculate permutations of words, Try with fewer words&#34;
        )
    except OSError as e:
        if e.errno == ENOSPC:
            print(
                &#34;[!] ERROR: (End Of Disk Space) There isn&#39;t enough disk space in the output directory, please provide another directory for the output file.&#34;
            )
    except KeyboardInterrupt:
        print(&#34;Keyboard Interrupt occurred!&#34;)

    if args.level == 0:
        print(f&#34;These operations have been done:\n&#34;)
        for item in output_print:
            print(f&#34;-{item}\n&#34;)

    
    print(
        f&#34;Wordlist with {word_counter} words created in: {default_timer() - start_time :.2f} seconds with Drowtsil&#34;
    )


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="drowtsil.create_wordlist"><code class="name flex">
<span>def <span class="ident">create_wordlist</span></span>(<span>iter, min, max, level, capital, regexp, pattern_dict, word_counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an iterable object and create a wordlist with selected options </p>
<p>Create a wordlist by joining items from iterators in one string. every iterator contains a list of all permutations
tuples. if a specific pattern is provided, it will be added and then passed to the private function (_add_to_wordlist). if
the level selected by the user is 2 and the capital switch doesn't disable, capitalized words also are added to the wordlist.</p>
<p>:param iter: iterable returns from itertools.permutations
:type iter: itertools.permutations
:param min: minimum size of word by char
:type min: int
:param max: maximum size of word by char
:type max: int
:param level: user's selected level
:type level: int
:param capital: enable capitalize case transformation
:type capital: bool
:param regexp: regex pattern to match
:type regexp: str
:param pattern_dict: pattern provided by the user
:type pattern_dict: dict
:param word_counter: tracking generated word number
:type word_counter: int
:returns: returns a list of generated words and their number
:rtype: tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_wordlist(iter, min, max, level, capital, regexp, pattern_dict, word_counter):
    &#34;&#34;&#34;Get an iterable object and create a wordlist with selected options 
    
    Create a wordlist by joining items from iterators in one string. every iterator contains a list of all permutations
    tuples. if a specific pattern is provided, it will be added and then passed to the private function (_add_to_wordlist). if
    the level selected by the user is 2 and the capital switch doesn&#39;t disable, capitalized words also are added to the wordlist.

    :param iter: iterable returns from itertools.permutations
    :type iter: itertools.permutations
    :param min: minimum size of word by char
    :type min: int
    :param max: maximum size of word by char
    :type max: int
    :param level: user&#39;s selected level
    :type level: int
    :param capital: enable capitalize case transformation
    :type capital: bool
    :param regexp: regex pattern to match
    :type regexp: str
    :param pattern_dict: pattern provided by the user
    :type pattern_dict: dict
    :param word_counter: tracking generated word number
    :type word_counter: int
    :returns: returns a list of generated words and their number
    :rtype: tuple
    &#34;&#34;&#34;
    wordlist = []
    for item in iter:
        word = &#34;&#34;.join(item)
        if pattern_dict:
            word = _add_pattern(word, pattern_dict)

        word_counter = _add_to_wordlist(wordlist, word, min, max, regexp, word_counter)
        #apply capitalize operation in level 2
        if level == 2 and capital:
            cap_word = &#34;&#34;.join(helpers.capitalize(item))
            if pattern_dict:
                cap_word = _add_pattern(cap_word, pattern_dict)

            word_counter = _add_to_wordlist(
                wordlist, cap_word, min, max, regexp, word_counter
            )

    return wordlist, word_counter</code></pre>
</details>
</dd>
<dt id="drowtsil.level_one"><code class="name flex">
<span>def <span class="ident">level_one</span></span>(<span>constant_words, temporary_words, numbers, chars)</span>
</code></dt>
<dd>
<div class="desc"><p>It performs when the user's selected level is 1. Get a list of URLs or other texts and add consecutive numbers or letters or
items of temporary_words at the end.</p>
<p>:param constant_words: a list of constant words
:type constant_words: list
:param temporary_words: a list of temporary words
:type temporary_words: list
:param numbers: limit for consecutive numbers - also enable this feature
:type numbers: int
:param chars: enable adding consecutive characters
:type chars: bool
:returns: a tuple contains a list of transformed words and the length of the wordlist
:rtype: tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def level_one(constant_words, temporary_words, numbers, chars):
    &#34;&#34;&#34;It performs when the user&#39;s selected level is 1. Get a list of URLs or other texts and add consecutive numbers or letters or
    items of temporary_words at the end.
    
    :param constant_words: a list of constant words
    :type constant_words: list
    :param temporary_words: a list of temporary words
    :type temporary_words: list
    :param numbers: limit for consecutive numbers - also enable this feature
    :type numbers: int
    :param chars: enable adding consecutive characters
    :type chars: bool
    :returns: a tuple contains a list of transformed words and the length of the wordlist 
    :rtype: tuple
    &#34;&#34;&#34;
    wordlist = []
    urls = _is_url(constant_words)
    # if input list contains urls
    if urls:
        for url in urls:
            if numbers:
                for i in range(numbers):
                    try:
                        new_url = &#34;&#34;.join(url[0]+str(i)+url[1])
                    except IndexError:
                        new_url = &#34;&#34;.join(url[0]+str(i))
                    wordlist.append(new_url)
            if temporary_words != &#34;&#34;:
                for tmp_item in temporary_words:
                    try:
                        new_url = &#34;&#34;.join(url[0]+str(tmp_item)+url[1])
                    except IndexError:
                        new_url = &#34;&#34;.join(url[0]+str(tmp_item))
                    wordlist.append(new_url)
            if chars:
                for char_item in helpers.characters:
                    try:
                        new_url = &#34;&#34;.join(url[0]+str(char_item)+url[1])
                    except IndexError:
                        new_url = &#34;&#34;.join(url[0]+str(char_item))
                    wordlist.append(new_url)
    # if input list does not contain urls.
    else:
        if numbers:
            for i in range(numbers):
                for item in constant_words:
                    wordlist.append(item + str(i))
        if temporary_words != &#34;&#34;:
            for tmp_item in temporary_words:
                for item in constant_words:
                    wordlist.append(item + tmp_item)
        if chars:
            for char_item in helpers.characters:
                for item in constant_words:
                    wordlist.append(item + char_item)
                    
    return wordlist, len(wordlist)</code></pre>
</details>
</dd>
<dt id="drowtsil.level_three"><code class="name flex">
<span>def <span class="ident">level_three</span></span>(<span>wordlist, args, output_dir, word_counter, semaphore, write_function)</span>
</code></dt>
<dd>
<div class="desc"><p>It performs when the user's selected level is 2. Get a list of words and arguments provided by the user and apply selected functions on
every item of the wordlist.</p>
<p>list of functions:
-upper case
-sentence case
-toggle case
-capitalize case
-leet case
-alternating case </p>
<p>:param wordlist: a list contains all permutations of input words
:type wordlist: list
:param args: arguments provided by the user
:type args: <class '__main__.Namespace'>
:param output_dir: path to the output directory
:type output_dir: str
:param word_counter: tracking generated word number
:type word_counter: int
:param semaphore: semaphore for prevent of mutual exclusion (default is 1)
:type semaphore: multiprocessing.synchronize.Semaphore
:param write_function: an instance of helpers.write_to_file function
:type write_function: function
:returns: returns number of generated words
:rtype: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def level_three(
    wordlist,
    args,
    output_dir,
    word_counter,
    semaphore,
    write_function,
):
    &#34;&#34;&#34;It performs when the user&#39;s selected level is 2. Get a list of words and arguments provided by the user and apply selected functions on
      every item of the wordlist.

      list of functions: 
      -upper case
      -sentence case
      -toggle case
      -capitalize case
      -leet case
      -alternating case 

    :param wordlist: a list contains all permutations of input words
    :type wordlist: list
    :param args: arguments provided by the user
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :param output_dir: path to the output directory
    :type output_dir: str
    :param word_counter: tracking generated word number
    :type word_counter: int
    :param semaphore: semaphore for prevent of mutual exclusion (default is 1)
    :type semaphore: multiprocessing.synchronize.Semaphore
    :param write_function: an instance of helpers.write_to_file function
    :type write_function: function
    :returns: returns number of generated words
    :rtype: int
    &#34;&#34;&#34;
    write_function(wordlist, semaphore, output_dir)
    temp_wordlist = []
    if args.all or args.leet_case:
        temp_wordlist += helpers.leet_case(wordlist)
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        #clear temp wordlist to save memory
        temp_wordlist.clear()
    if args.all or args.upper:
        temp_wordlist += set(helpers.upper_case(wordlist))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear()
    if args.all or args.sentence:
        temp_wordlist += set(helpers.sentence_case(wordlist))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear() 
    if args.all or args.toggle is not None:
        if args.all and args.toggle is None:
            args.toggle = 0
        temp_wordlist += set(helpers.toggle_case(wordlist, index=args.toggle))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear()
    if args.all or args.alternating:
        temp_wordlist += set(helpers.alternating_case(wordlist))
        write_function(temp_wordlist, semaphore, output_dir)
        word_counter += len(temp_wordlist)
        temp_wordlist.clear()
    #clear wordlist to save memory
    wordlist.clear()

    return word_counter</code></pre>
</details>
</dd>
<dt id="drowtsil.level_zero"><code class="name flex">
<span>def <span class="ident">level_zero</span></span>(<span>args, current_words)</span>
</code></dt>
<dd>
<div class="desc"><p>It performs when the user's selected level is 0. Get a list of words and arguments provided by the user and apply selected functions on
all items.</p>
<p>list of functions:
-upper case
-lower case,
-toggle case
-swap case
-capitalize case
-leet case
-reverse case
-alternating case </p>
<p>:param args: arguments provide by the user
:type args: <class '__main__.Namespace'>
:param current_words: a merged list of constant words and temporary words
:type current_words: list
:returns: a tuple contains a list of transformed words and a list of operations that have been done
:rtype: tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def level_zero(args, current_words):
    &#34;&#34;&#34;It performs when the user&#39;s selected level is 0. Get a list of words and arguments provided by the user and apply selected functions on
      all items.

    list of functions: 
      -upper case
      -lower case,
      -toggle case
      -swap case
      -capitalize case
      -leet case
      -reverse case
      -alternating case 

    :param args: arguments provide by the user
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :param current_words: a merged list of constant words and temporary words
    :type current_words: list
    :returns: a tuple contains a list of transformed words and a list of operations that have been done 
    :rtype: tuple
    &#34;&#34;&#34;
    words = []
    output_print = []
    if args.all or args.upper:
        words += helpers.upper_case(current_words)
        output_print.append(&#34;upper case&#34;)
    if args.all or args.lower:
        words += helpers.lower_case(current_words)
        output_print.append(&#34;lower case&#34;)
    if args.all or args.toggle is not None:
        if args.all and args.toggle is None:
            args.toggle = 0
        words += helpers.toggle_case(current_words, args.toggle)
        output_print.append(&#34;toggle case&#34;)
    if args.all or args.swap:
        words += helpers.swap_case(current_words)
        output_print.append(&#34;swap case&#34;)
    if args.all or args.capital:
        words += helpers.capitalize(current_words)
        output_print.append(&#34;capitalize&#34;)
    if args.all or args.leet_case:
        words += helpers.leet_case(current_words)
        output_print.append(&#34;leet_case&#34;)
    if args.all or args.reverse:
        words += helpers.reverse(current_words)
        output_print.append(&#34;reverse&#34;)
    if args.all or args.alternating:
        words += helpers.alternating_case(current_words)
        output_print.append(&#34;alternating&#34;)
    return set(words), output_print</code></pre>
</details>
</dd>
<dt id="drowtsil.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function to generate a wordlist</p>
<p>:param args: arguments provided by the user - optional
:type args: <class '__main__.Namespace'>
:returns: None
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args=None):
    &#34;&#34;&#34;Main function to generate a wordlist

    :param args: arguments provided by the user - optional
    :type args: &lt;class &#39;__main__.Namespace&#39;&gt;
    :returns: None
    :rtype: None
    &#34;&#34;&#34;
    #specifies start method for multiprocessing mode
    start_method = get_all_start_methods()
    set_start_method(start_method[0])
    #calculate logical cpu cores
    process_number_default = cpu_count()
    #record progress time
    start_time = default_timer()
    #assign functions for testing purpose
    write_function = helpers.write_to_file
    read_function = helpers.read_from_file
    #create argument parser
    parser = _create_parser(process_number_default)
    args = parser.parse_args()
    #extract constant and temporary lists
    cons_words, tmp_words = _extract_user_input(args, parser, read_function)
    len_input = len(cons_words)
    total = _calculate_total(tmp_words, len_input, args.pernumber)
    output_dir = Path(args.output)
    semaphore = Semaphore(1)
    iteration_number = 0
    word_counter = 0
    print_bar = helpers.printProgressBar
    pattern_dict = _extract_pattern(args)
    print(logo)

    # emptying previous output file
    mode = &#34;w&#34;
    with open(output_dir, mode):
        pass
    
    try:
        if args.level == 0:
                wordlist, output_print = level_zero(args, cons_words)
                write_function(wordlist, semaphore, output_dir)
                word_counter = len(wordlist)

        elif args.level == 1:
                wordlist, word_counter = level_one(cons_words, tmp_words, args.numbers, args.chars)
                write_function(wordlist, semaphore, output_dir)
        
        else:
            print_bar(iteration_number, total, length=50)

            for item in tmp_words:
                #each time initialize a list of words from the constant list and one item from the temporary list
                current_words = [item]
                current_words += cons_words
                # checking for high number of permutations
                if len_input+1 &gt;= 12:
                    _checking_permutation_number(len_input, parser)
                #calculate permutation without multiprocessing
                if not args.process:
                    for i in range(args.pernumber, len_input + 2):
                        iter = permutations(current_words, i)
                        wordlist, word_counter = create_wordlist(
                            iter,
                            args.min,
                            args.max,
                            args.level,
                            args.capital,
                            args.regex,
                            pattern_dict,
                            word_counter,
                        )

                        if args.level == 2:
                            write_function(wordlist, semaphore, output_dir)

                            iteration_number += 1
                            helpers.printProgressBar(iteration_number, total, length=50)
                            
                        if args.level == 3:
                            word_counter = level_three(
                                wordlist,
                                args,
                                output_dir,
                                word_counter,
                                semaphore,
                                write_function,
                            )
                            iteration_number += 1
                            helpers.printProgressBar(iteration_number, total, length=50)
                if args.process:
                    starmap_iterable = [
                        (current_words, i) for i in range(args.pernumber, len_input + 2)
                    ]
                    #calculate permutation with multiprocessing
                    with Pool(processes=args.process) as pool:
                        for iter in pool.starmap(permutations, starmap_iterable):
                            wordlist, word_counter = create_wordlist(
                                iter,
                                args.min,
                                args.max,
                                args.level,
                                args.capital,
                                args.regex,
                                pattern_dict,
                                word_counter,
                            )
                            if args.level == 1:
                                write_function(wordlist, semaphore, output_dir)

                                iteration_number += 1
                                helpers.printProgressBar(
                                    iteration_number, total, length=50
                                )
                            if args.level == 2:
                                word_counter = level_three(
                                    wordlist,
                                    args,
                                    output_dir,
                                    word_counter,
                                    semaphore,
                                    write_function,
                                )
                            iteration_number += 1
                            helpers.printProgressBar(iteration_number, total, length=50)

    except MemoryError:
        print(
            &#34;[!] ERROR:(Memory error) There isn&#39;t enough memory to calculate permutations of words, Try with fewer words&#34;
        )
    except OSError as e:
        if e.errno == ENOSPC:
            print(
                &#34;[!] ERROR: (End Of Disk Space) There isn&#39;t enough disk space in the output directory, please provide another directory for the output file.&#34;
            )
    except KeyboardInterrupt:
        print(&#34;Keyboard Interrupt occurred!&#34;)

    if args.level == 0:
        print(f&#34;These operations have been done:\n&#34;)
        for item in output_print:
            print(f&#34;-{item}\n&#34;)

    
    print(
        f&#34;Wordlist with {word_counter} words created in: {default_timer() - start_time :.2f} seconds with Drowtsil&#34;
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="drowtsil.create_wordlist" href="#drowtsil.create_wordlist">create_wordlist</a></code></li>
<li><code><a title="drowtsil.level_one" href="#drowtsil.level_one">level_one</a></code></li>
<li><code><a title="drowtsil.level_three" href="#drowtsil.level_three">level_three</a></code></li>
<li><code><a title="drowtsil.level_zero" href="#drowtsil.level_zero">level_zero</a></code></li>
<li><code><a title="drowtsil.main" href="#drowtsil.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>